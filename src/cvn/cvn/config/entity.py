from ..utils import code as cvn_code
import cvn.config.property as cvn_property
from rdflib.namespace import RDF
from rdflib import Literal, URIRef, BNode
import uuid
from cvn.config.relationship import Relationship
import requests
import re
import cvn.config.condition as cvn_condition
import cvn.config.entitycache as cvn_entity_cache
import urllib.parse
import cvn.utils.xmltree as xmltree
import cvn.webserver as web_server
import logging
import os


# Caché de URIs generadas
# TODO mover a un servicio externo, o hacer algo más elaborado
# Problema: memoria...? múltiples ejecuciones = se borra
cached_uris = {}


def generate_uri(resource_class, identifier):
    """
    Generar, usando la API HTTP, las URIs correspondientes a cada entidad.
    :param resource_class:
    :param identifier:
    :return: la URI
    """
    
    if web_server.debug:
        return "http://data.um.es/class/" + resource_class + "/" + identifier

    # Antes de intentar obtener la URI, comprobar a ver si la tenemos ya en caché
    cache_id = resource_class + "." + identifier
    if cache_id in cached_uris:
        return cached_uris[cache_id]
     
    # Quitar verify=False
    url_uris_factory = os.getenv('ConfigUrlUrisFactory')
    if url_uris_factory is None:
        url_uris_factory = "http://herc-as-front-desa.atica.um.es/uris/"
    url_uris_factory += "Factory"
    api_response = requests.get(url_uris_factory, params={
        'resource_class': resource_class,
        'identifier': identifier
    })  # TODO comprobar que lo que devuelve es de hecho una URL bien formateada

    # Si falla, nos la jugamos y nos inventamos una URI que podría ser:
    if api_response.status_code != 200:
        return "http://data.um.es/class/" + resource_class + "/" + identifier

    # Guardamos en caché si ha salido bien
    result = api_response.text
    cached_uris[cache_id] = result
    return result


def init_entity_from_serialized_toml(config, parent=None):
    # code and name are required attributes

    code = None
    if 'code' not in config:
        # if code is not set but we have a parent, set it to the parent's code
        if (parent is not None) and (parent.code is not None):
            code = parent.code
        else:
            raise KeyError('code not specified for Entity')
    else:
        code = config['code']

    if not cvn_code.is_cvn_code_valid(code):
        raise ValueError('code does not match expected format: ' + config['code'])

    ontology = "owl"
    classname = "Thing"

    if 'displayname' in config:
        display_name_format = re.compile("^[a-zA-Z]+:\w+$")
        if re.match(display_name_format, config['displayname']):
            split = config['displayname'].split(":")
            ontology = split[0]
            classname = split[1]
        else:
            raise ValueError('displayname has invalid format: ' + config['displayname'])
    else:
        if 'ontology' not in config:
            raise KeyError('ontology not specified for Entity')
            # TODO comprobar que está definida

        if 'classname' not in config:
            raise KeyError('classname not specified for Entity')

        ontology = config['ontology']
        classname = config['classname']

    # ID
    config_id_format = None
    config_id_resource = None
    if 'id' in config:
        if 'format' in config['id']:
            config_id_format = config['id']['format'].replace(":", "_")
        if 'resource' in config['id']:
            config_id_resource = config['id']['resource']

    primary = False
    if 'primary' in config:
        primary = config['primary']

    cache_property = None
    if 'cache' in config:
        cache_property = config['cache']

    sub_code = False
    if 'subcode' in config:
        sub_code = config['subcode']

    uri = None
    if 'uri' in config:
        uri = config['uri']

    entity = Entity(code=code, ontology=ontology, classname=classname, parent=parent,
                    identifier_config_resource=config_id_resource, identifier_config_format=config_id_format,
                    primary=primary, property_cache=cache_property, sub_code=sub_code, uri=uri)

    # Populate properties
    if 'properties' in config:
        for property_config in config['properties']:
            property_generated = cvn_property.init_property_from_serialized_toml(property_config, entity)
            entity.add_property(property_generated)
            property_generated.parent = entity

    # Relationships
    if 'relationships' in config:
        for relationship in config['relationships']:

            ontology = None
            name = None

            if 'direct' in relationship:
                split = relationship['direct'].split(":")
                ontology = split[0]
                name = split[1]
            else:
                if 'name' in relationship:
                    if 'ontology' not in relationship:
                        raise KeyError('Relationship name was specified but no ontology for it')
                        # TODO comprobar que está definida
                    name = relationship['name']
                    ontology = relationship['ontology']

            inverse_name = None
            inverse_ontology = None
            if 'inverse' in relationship:
                split = relationship['inverse'].split(":")
                inverse_ontology = split[0]
                inverse_name = split[1]
            else:
                if 'inverse_name' in relationship:
                    if 'inverse_ontology' not in relationship:
                        raise KeyError('inverse Relationship name was specified but no ontology for it')
                        # TODO comprobar que está definida
                    inverse_name = relationship['inverse_name']
                    inverse_ontology = relationship['inverse_ontology']

            link_to_cvn_person = False
            if 'link_to_cvn_person' in relationship:
                link_to_cvn_person = relationship['link_to_cvn_person']

            if ((name is not None) and (ontology is not None)) \
                    or ((inverse_name is not None) and (inverse_ontology is not None)):
                generated_relationship = Relationship(ontology, name, inverse_ontology,
                                                      inverse_name, link_to_cvn_person, parent=entity)
                entity.add_relationship(generated_relationship)

    # Conditions
    if 'conditions' in config:
        for condition in config['conditions']:
            entity.add_condition(cvn_condition.init_condition_from_serialized_toml(condition, entity))

    # Subentities, recursive (optional)
    if 'subentities' in config:
        for subentity in config['subentities']:
            entity.add_subentity(init_entity_from_serialized_toml(subentity, entity))

    return entity


def comprobar_propiedad(propiedad):
    if propiedad is not None and len(propiedad) > 0:
        return True
    return False


class Entity:
    # TODO todo el tema de la id y la URI
    def __init__(self, code, ontology, classname, parent=None, identifier_config_resource=None,
                 identifier_config_format=None, primary=False, property_cache=None, sub_code=False, uri=None):
        self.code = code
        self.sub_code = sub_code
        self.ontology = ontology
        self.classname = classname
        self.subentities = []
        self.generated_subentities = []
        self.properties = []
        self.relationships = []
        self.parent = parent
        self.triplets = []
        self.generated_identifier = None
        self.identifier_config_resource = identifier_config_resource
        self.identifier_config_format = identifier_config_format
        self.node = None
        self.xml_item = None
        self.primary = primary
        self.conditions = []
        self.property_cache = property_cache
        self.uri = uri

    def add_property(self, entity_property):
        """
        Adds a property to the Entity
        :param entity_property: the Property to add
        :return: the resulting Entity
        """
        self.properties.append(entity_property)
        return self

    def add_relationship(self, relationship):
        self.relationships.append(relationship)

    def add_subentity(self, subentity):
        self.subentities.append(subentity)
        return self

    def add_condition(self, condition):
        self.conditions.append(condition)
        return self

    def generate_and_add_to_ontology(self, ontology_config, xml_tree, skip_subentities_with_subcode=True, do_loop=True):
        if do_loop:
            for entity_result_node in xmltree.get_all_nodes_by_code(xml_tree, self.code):
                logging.debug("generating w/ loop: " + self.classname)
                self.get_property_values_from_node(entity_result_node, skip_subentities_with_subcode)
                if not self.should_generate():
                    continue
                self.add_entity_to_ontology(ontology_config, skip_subentities_with_subcode)
                if self.primary:
                    ontology_config.cvn_person = self.get_uri()

                for sub_entity in self.subentities:
                    loop = False
                    node = entity_result_node
                    if sub_entity.sub_code:
                        logging.debug("subcode loop")
                        loop = True
                    sub_entity.generate_and_add_to_ontology(ontology_config, node,
                                                            skip_subentities_with_subcode=False, do_loop=loop)
                self.clear_values()
        else:
            logging.debug("generating " + self.classname)
            self.get_property_values_from_node(xml_tree, skip_subentities_with_subcode)
            if not self.should_generate():
                return
            self.add_entity_to_ontology(ontology_config, skip_subentities_with_subcode)

            for sub_entity in self.subentities:
                loop = False
                if sub_entity.sub_code:
                    logging.debug("subcode no loop " + str(xml_tree))
                    loop = True
                    sub_entity.generate_and_add_to_ontology(ontology_config, xml_tree,
                                                            skip_subentities_with_subcode=False, do_loop=loop)
                else:
                    sub_entity.generate_and_add_to_ontology(ontology_config, xml_tree,
                                                            skip_subentities_with_subcode=False, do_loop=loop)
            self.clear_values()

    def get_property_values_from_node(self, item_node, skip_subentities_with_subcode):
        for property_item in self.properties:
            property_item.get_value_from_node(item_node)
        self.xml_item = item_node

    def clear_values(self, include_sub_entities_with_sub_code=False):
        if self.uri is None:
            self.generated_identifier = None
        for property_item in self.properties:
            property_item.clear_values()
        self.node = None
        self.xml_item = None
        for subentity in self.subentities:
            if include_sub_entities_with_sub_code or not subentity.sub_code:
                subentity.clear_values()
        return self

    def is_blank_node(self):
        if self.uri is not None:
            return False
        return self.identifier_config_resource is None

    def get_identifier(self):
        if self.uri is not None:
            return self.uri

        if self.generated_identifier is None:

            resource = self.classname
            if self.identifier_config_resource is not None:
                resource = self.identifier_config_resource

            identifier = str(uuid.uuid4())
            if self.identifier_config_format is not None:
                property_dict = self.get_property_dict(format_safe=True)
                if has_all_formatting_fields(self.identifier_config_format, property_dict):
                    identifier = urllib.parse.quote_plus(self.identifier_config_format.format_map(property_dict))

            self.generated_identifier = generate_uri(resource, identifier)

        return self.generated_identifier

    def get_uri(self):
        uri_urisfactory = self.get_identifier()
        # Si el UrisFactory devuelve "_:", es un BlankNode.
        if uri_urisfactory[0] == "N":
            #if self.is_blank_node():
            if self.node is None:
                self.node = BNode(uri_urisfactory)
            return self.node
        else:
            if self.should_cache():
                if cvn_entity_cache.get_current_entity_cache().in_cache(self.get_cache_id().lower()):
                    return cvn_entity_cache.get_current_entity_cache().get(self.get_cache_id().lower())
                else:
                    uri = URIRef(self.get_identifier())
                    cvn_entity_cache.get_current_entity_cache().add_to_cache(self.get_cache_id().lower(), uri)
                    return uri
        return URIRef(self.get_identifier())

    def generate_entity_triple(self, ontology_config):
        return self.get_uri(), RDF.type, ontology_config.get_ontology(self.ontology).term(self.classname)

    def generate_property_triples(self, ontology_config):
        triples = []
        default_type = ontology_config.get_default_data_type()
        for property_item in self.properties:

            # Si tiene como segundo apellido "-", no lo pone.
            if property_item.formatted_value is not None and len(property_item.formatted_value) > 0 and property_item.formatted_value[-1] == "-":
                property_item.formatted_value = property_item.formatted_value[0: len(property_item.formatted_value) - 2]

            # Si la propiedad está vacía, no la añade.
            if comprobar_propiedad(property_item.formatted_value):

                if property_item.should_generate():

                    # Valores por defecto: el tipo de datos definido como default y la propiedad como string simplón
                    literal_type = ontology_config.get_ontology(default_type.ontology).term(default_type.name)
                    property_value = str(property_item.formatted_value)

                    # ¿Tiene la propiedad un tipo de dato específico? Si no, nos quedamos con el default
                    if property_item.data_type is not None:
                        # El tipo de dato definido para la propiedad, ¿existe? - si no, el default
                        data_type = ontology_config.get_data_type(property_item.data_type)
                        if data_type is not None:
                            # Intentamos convertir el string en su tipo de dato correspondiente
                            try:
                                property_value = (data_type.get_python_type())(property_value)
                                literal_type = ontology_config.get_ontology(data_type.ontology).term(data_type.name)
                            except TypeError:
                                pass

                            if data_type.force:
                                literal_type = ontology_config.get_ontology(data_type.ontology).term(data_type.name)

                    triple = self.get_uri(), \
                             ontology_config.get_ontology(property_item.ontology).term(property_item.name), \
                             Literal(property_value, datatype=literal_type)

                    triples.append(triple)
        return triples

    def generate_relationship_triples(self, ontology_config):
        triples = []
        for relationship in self.relationships:

            if relationship.link_to_cvn_person:
                other = ontology_config.cvn_person
                # TODO comprobar que person no sea None
            else:
                if self.parent is None:
                    continue  # Si es una relación con el padre, pero no tiene... nos la saltamos
                other = self.parent.get_uri()

            # Relación directa
            if (relationship.name is not None) and (relationship.ontology is not None):

                # Rellenar el nombre de la propiedad con el valor de la propiedad correspondiente, si existiera
                name = relationship.name
                property_dict = self.get_property_dict(format_safe=True)
                if '{' in name:
                    if has_all_formatting_fields(name, property_dict):
                        name = name.format_map(property_dict)
                    else:
                        continue

                direct_triple = self.get_uri(), \
                                ontology_config.get_ontology(relationship.ontology).term(name), \
                                other
                triples.append(direct_triple)

            # Relación inversa
            if (relationship.inverse_name is not None) and \
                    (relationship.inverse_ontology is not None):

                # Rellenar el nombre de la propiedad con el valor de la propiedad correspondiente, si existiera
                name = relationship.inverse_name
                property_dict = self.get_property_dict(format_safe=True)
                if '{' in name:
                    if has_all_formatting_fields(name, property_dict):
                        name = name.format_map(property_dict)
                    else:
                        continue

                inverse_triple = other, ontology_config.get_ontology(relationship.inverse_ontology) \
                    .term(name), self.get_uri()
                triples.append(inverse_triple)
            else:
                continue

        return triples

    def add_entity_to_ontology(self, ontology_config, skip_subentities_with_subcode):
        if not self.should_generate():
            return

        if self.uri is None:
            # Propiedades
            propiedades = self.generate_property_triples(ontology_config)

            # Relaciones
            relationship_triples = self.generate_relationship_triples(ontology_config)

            if len(propiedades) > 0 or len(relationship_triples) > 0:
                for triple in propiedades:
                    ontology_config.graph.add(triple)
                for triple in relationship_triples:
                    ontology_config.graph.add(triple)

                tripleEntidad = self.generate_entity_triple(ontology_config)
                ontology_config.graph.add(tripleEntidad)

            # Subentidades
            for subentity in self.subentities:
                if skip_subentities_with_subcode and subentity.sub_code:
                    subentity.add_entity_to_ontology(ontology_config, skip_subentities_with_subcode)
                else:
                    subentity.add_entity_to_ontology(ontology_config, skip_subentities_with_subcode)
        else:
            print("Uri inválida.")

    def get_property_dict(self, format_safe=False):
        properties = {}
        for property_item in self.properties:
            if property_item.formatted_value is not None:
                if format_safe:
                    properties[property_item.get_format_safe_identifier()] = property_item.formatted_value
                else:
                    properties[property_item.get_identifier()] = property_item.formatted_value
        return properties

    def should_generate(self):
        if (len(self.properties) > 0) and self.are_properties_empty():
            return False

        if (len(self.properties) > 0) and self.is_a_required_property_missing():
            return False

        for condition in self.conditions:
            if not condition.is_met():
                return False
        return True

    def are_properties_empty(self):
        for property_item in self.properties:
            if property_item.formatted_value is not None:
                return False
        for subentity in self.subentities:
            if not subentity.are_properties_empty():
                return False
        return True

    def is_a_required_property_missing(self):
        for property_item in self.properties:
            if property_item.required and not property_item.should_generate():
                return True
        return False

    def should_cache(self):
        if self.property_cache is None:
            return False
        for property_item in self.properties:
            if property_item.get_identifier() == self.property_cache:
                if property_item.formatted_value is not None:
                    return True
        return False

    def get_cache_id(self):
        if self.property_cache is None:
            return None
        cached_property = None
        for property_item in self.properties:
            if property_item.get_identifier() == self.property_cache:
                cached_property = property_item.formatted_value
                break
        return self.ontology + ":" + self.classname + ":" + cached_property


def has_all_formatting_fields(format_string, fields):
    """
    Comprueba que todos los campos de formateo estén definidos en el diccionario
    :param format_string: el texto que se le pasa al Formatter
    :param fields: los campos con los valores que se usan para rellenar
    :return: bool ¿están todos los campos de formateo cubiertos por el diccionario?
    """
    # Busca los valores entre {} y los devuelve en una lista
    format_fields = re.findall(r'{(.*?)}', format_string)

    for field in format_fields:
        if field not in fields:
            return False
    return True
